<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Voice Test</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 16px;
    }
    
    h1 {
      font-size: 20px;
      margin-bottom: 16px;
      color: #4CAF50;
    }
    
    .section {
      background: #252542;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .section h2 {
      font-size: 14px;
      color: #888;
      margin-bottom: 12px;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
      font-weight: bold;
    }
    
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #666;
    }
    
    .status-dot.listening {
      background: #4CAF50;
      animation: pulse 1s infinite;
    }
    
    .status-dot.processing {
      background: #FF9800;
    }
    
    .status-dot.ready {
      background: #2196F3;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
      font-family: monospace;
    }
    
    .stat-label {
      font-size: 11px;
      color: #888;
    }
    
    button {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-play {
      background: #4CAF50;
      color: white;
    }
    
    .btn-play:active:not(:disabled) {
      transform: scale(0.98);
    }
    
    .log {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      color: #aaa;
    }
    
    .log-entry {
      margin-bottom: 4px;
    }
    
    .log-entry.error {
      color: #f44336;
    }
    
    .log-entry.success {
      color: #4CAF50;
    }
    
    .hint {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¤ Voice Test</h1>
  
  <div class="section">
    <h2>Status</h2>
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Idle</span>
    </div>
    <p class="hint">Press KEY2 on Tapir to record</p>
    <p class="hint">Decoder: <span id="decoderStatus" style="color: #FF9800;">Loading...</span></p>
  </div>
  
  <div class="section">
    <h2>Live Stats</h2>
    <div class="stats">
      <div>
        <div class="stat-value" id="packetCount">0</div>
        <div class="stat-label">Packets</div>
      </div>
      <div>
        <div class="stat-value" id="bytesReceived">0</div>
        <div class="stat-label">Bytes</div>
      </div>
      <div>
        <div class="stat-value" id="duration">0.0s</div>
        <div class="stat-label">Duration</div>
      </div>
    </div>
  </div>
  
  <div class="section">
    <h2>Last Clip</h2>
    <button class="btn-play" id="playBtn" disabled>â–¶ Play Recording</button>
    <p class="hint" id="clipInfo">No recording yet</p>
  </div>
  
  <div class="section">
    <h2>Log</h2>
    <div class="log" id="log"></div>
  </div>

  <script>
    // ============================================================
    // State
    // ============================================================
    
    let opusFrames = [];
    let isRecording = false;
    let recordingStart = 0;
    let audioContext = null;
    let lastAudioBuffer = null;
    let durationInterval = null;
    
    // No external decoder needed - using native Web Audio API + OGG container
    document.getElementById('decoderStatus').textContent = 'âœ“ Native';
    document.getElementById('decoderStatus').style.color = '#4CAF50';
    
    // ============================================================
    // UI Elements
    // ============================================================
    
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const packetCountEl = document.getElementById('packetCount');
    const bytesReceivedEl = document.getElementById('bytesReceived');
    const durationEl = document.getElementById('duration');
    const playBtn = document.getElementById('playBtn');
    const clipInfoEl = document.getElementById('clipInfo');
    const logEl = document.getElementById('log');
    
    // ============================================================
    // Logging
    // ============================================================
    
    function log(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry' + (type !== 'info' ? ' ' + type : '');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(`[VoiceTest] ${msg}`);
    }
    
    // ============================================================
    // Voice Event Handlers
    // ============================================================
    
    function onVoiceStart() {
      log('Recording started');
      isRecording = true;
      recordingStart = Date.now();
      opusFrames = [];
      
      // Update UI
      statusDot.className = 'status-dot listening';
      statusText.textContent = 'Recording...';
      packetCountEl.textContent = '0';
      bytesReceivedEl.textContent = '0';
      durationEl.textContent = '0.0s';
      
      // Start duration timer
      durationInterval = setInterval(() => {
        const dur = (Date.now() - recordingStart) / 1000;
        durationEl.textContent = dur.toFixed(1) + 's';
      }, 100);
    }
    
    function onVoiceData(data) {
      if (!isRecording) return;
      
      // data.audio is base64-encoded Opus frame
      const opusBase64 = data.audio;
      if (opusBase64) {
        // Decode base64 to Uint8Array
        const binary = atob(opusBase64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        opusFrames.push(bytes);
        
        // Update stats
        const totalBytes = opusFrames.reduce((sum, f) => sum + f.length, 0);
        packetCountEl.textContent = opusFrames.length;
        bytesReceivedEl.textContent = totalBytes < 1024 
          ? totalBytes + ' B' 
          : (totalBytes / 1024).toFixed(1) + ' KB';
      }
    }
    
    async function onVoiceEnd() {
      log(`Recording ended: ${opusFrames.length} packets`);
      isRecording = false;
      
      // Stop duration timer
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
      }
      
      // Update UI
      statusDot.className = 'status-dot processing';
      statusText.textContent = 'Processing...';
      
      if (opusFrames.length === 0) {
        log('No audio data received', 'error');
        statusDot.className = 'status-dot';
        statusText.textContent = 'Idle';
        return;
      }
      
      // Try to decode Opus
      try {
        await decodeOpusFrames();
        statusDot.className = 'status-dot ready';
        statusText.textContent = 'Ready to play';
        playBtn.disabled = false;
        
        const totalBytes = opusFrames.reduce((sum, f) => sum + f.length, 0);
        const duration = lastAudioBuffer ? lastAudioBuffer.duration.toFixed(2) : '?';
        clipInfoEl.textContent = `${opusFrames.length} packets, ${totalBytes} bytes, ${duration}s`;
        
        log(`Decoded successfully: ${duration}s audio`, 'success');
      } catch (err) {
        log(`Decode failed: ${err.message}`, 'error');
        statusDot.className = 'status-dot';
        statusText.textContent = 'Decode failed';
        clipInfoEl.textContent = 'Decode error - see log';
      }
    }
    
    // ============================================================
    // Opus Decoding (Native Web Audio + OGG container)
    // ============================================================
    
    async function decodeOpusFrames() {
      // Initialize AudioContext
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      log(`Wrapping ${opusFrames.length} Opus frames in OGG container...`);
      
      // Build OGG/Opus container from raw frames
      const oggData = buildOggOpus(opusFrames, 16000, 1);
      log(`OGG container: ${oggData.length} bytes`);
      
      // Decode using native Web Audio API
      const arrayBuffer = oggData.buffer.slice(
        oggData.byteOffset,
        oggData.byteOffset + oggData.byteLength
      );
      
      try {
        lastAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        log(`Decoded: ${lastAudioBuffer.duration.toFixed(2)}s @ ${lastAudioBuffer.sampleRate}Hz`);
      } catch (err) {
        log(`Native decode failed: ${err.message}`, 'error');
        throw err;
      }
    }
    
    // ============================================================
    // OGG/Opus Container Builder (RFC 7845)
    // ============================================================
    
    function buildOggOpus(frames, sampleRate, channels) {
      const pages = [];
      let pageSequence = 0;
      let granulePosition = 0;
      
      // Pre-skip: 312 samples for 16kHz (standard Opus encoder delay)
      const preSkip = 312;
      
      // OpusHead packet (19 bytes)
      const opusHead = new Uint8Array([
        0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64, // "OpusHead"
        0x01,                                             // Version
        channels,                                         // Channels
        preSkip & 0xFF, (preSkip >> 8) & 0xFF,           // Pre-skip (LE)
        sampleRate & 0xFF, (sampleRate >> 8) & 0xFF,     // Sample rate (LE)
        (sampleRate >> 16) & 0xFF, (sampleRate >> 24) & 0xFF,
        0x00, 0x00,                                       // Output gain
        0x00                                              // Channel mapping
      ]);
      
      // OpusTags packet
      const vendor = 'tapir';
      const opusTags = new Uint8Array(8 + 4 + vendor.length + 4);
      const tagsView = new DataView(opusTags.buffer);
      opusTags.set([0x4F, 0x70, 0x75, 0x73, 0x54, 0x61, 0x67, 0x73]); // "OpusTags"
      tagsView.setUint32(8, vendor.length, true);
      for (let i = 0; i < vendor.length; i++) {
        opusTags[12 + i] = vendor.charCodeAt(i);
      }
      tagsView.setUint32(12 + vendor.length, 0, true); // 0 comments
      
      // Page 1: OpusHead (BOS)
      pages.push(buildOggPage(opusHead, 0, pageSequence++, 0x02, true));
      
      // Page 2: OpusTags
      pages.push(buildOggPage(opusTags, 0, pageSequence++, 0x00, false));
      
      // Audio pages - one frame per page for simplicity
      const samplesPerFrame = 320; // 20ms at 16kHz
      for (let i = 0; i < frames.length; i++) {
        granulePosition += samplesPerFrame;
        const isLast = i === frames.length - 1;
        pages.push(buildOggPage(frames[i], granulePosition, pageSequence++, isLast ? 0x04 : 0x00, false));
      }
      
      // Concatenate all pages
      const totalSize = pages.reduce((sum, p) => sum + p.length, 0);
      const result = new Uint8Array(totalSize);
      let offset = 0;
      for (const page of pages) {
        result.set(page, offset);
        offset += page.length;
      }
      
      return result;
    }
    
    function buildOggPage(data, granulePos, seqNum, flags, isBOS) {
      // Calculate segment table
      const segments = [];
      let remaining = data.length;
      while (remaining >= 255) {
        segments.push(255);
        remaining -= 255;
      }
      segments.push(remaining);
      
      const headerSize = 27 + segments.length;
      const page = new Uint8Array(headerSize + data.length);
      const view = new DataView(page.buffer);
      
      // Magic: "OggS"
      page.set([0x4F, 0x67, 0x67, 0x53], 0);
      
      // Version
      page[4] = 0;
      
      // Flags
      page[5] = flags;
      
      // Granule position (64-bit LE)
      view.setUint32(6, granulePos, true);
      view.setUint32(10, 0, true); // High 32 bits
      
      // Serial number
      view.setUint32(14, 0x54415049, true); // "TAPI" as serial
      
      // Page sequence
      view.setUint32(18, seqNum, true);
      
      // CRC (placeholder, calculate after)
      view.setUint32(22, 0, true);
      
      // Segment count
      page[26] = segments.length;
      
      // Segment table
      for (let i = 0; i < segments.length; i++) {
        page[27 + i] = segments[i];
      }
      
      // Data
      page.set(data, headerSize);
      
      // Calculate and set CRC
      const crc = oggCrc32(page);
      view.setUint32(22, crc, true);
      
      return page;
    }
    
    // OGG CRC-32 lookup table
    const oggCrcTable = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let r = i << 24;
      for (let j = 0; j < 8; j++) {
        r = (r & 0x80000000) ? ((r << 1) ^ 0x04C11DB7) : (r << 1);
      }
      oggCrcTable[i] = r >>> 0;
    }
    
    function oggCrc32(data) {
      let crc = 0;
      for (let i = 0; i < data.length; i++) {
        crc = (oggCrcTable[((crc >>> 24) ^ data[i]) & 0xFF] ^ (crc << 8)) >>> 0;
      }
      return crc;
    }
    
    // ============================================================
    // Playback
    // ============================================================
    
    async function playAudio() {
      if (!lastAudioBuffer) {
        log('No audio to play', 'error');
        return;
      }
      
      // Resume AudioContext if suspended (autoplay policy)
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      
      log('Playing audio...');
      playBtn.disabled = true;
      playBtn.textContent = 'â–¶ Playing...';
      
      const source = audioContext.createBufferSource();
      source.buffer = lastAudioBuffer;
      source.connect(audioContext.destination);
      
      source.onended = () => {
        log('Playback complete', 'success');
        playBtn.disabled = false;
        playBtn.textContent = 'â–¶ Play Recording';
      };
      
      source.start();
    }
    
    playBtn.addEventListener('click', playAudio);
    
    // ============================================================
    // Bridge Integration
    // ============================================================
    
    // Prevent duplicate registration
    let bridgeRegistered = false;
    
    function setupBridge() {
      if (bridgeRegistered) {
        log('Bridge already registered, skipping');
        return;
      }
      
      if (window.tapir) {
        bridgeRegistered = true;
        log('Bridge connected');
        
        // Listen for voice events
        window.tapir.on('voice', (event) => {
          switch (event.type) {
            case 'start':
              onVoiceStart();
              break;
            case 'data':
              onVoiceData(event);
              break;
            case 'end':
              onVoiceEnd();
              break;
          }
        });
        
        log('Listening for voice events');
      } else {
        log('No bridge detected', 'error');
      }
    }
    
    // Try to setup bridge now, or wait for it
    if (window.tapir) {
      setupBridge();
    } else {
      // Bridge might be injected after script runs
      let attempts = 0;
      const checkBridge = setInterval(() => {
        attempts++;
        if (window.tapir) {
          clearInterval(checkBridge);
          setupBridge();
        } else if (attempts > 20) {
          clearInterval(checkBridge);
          log('Bridge not available after 2s', 'error');
        }
      }, 100);
    }
    
    log('Voice Test mini-app loaded');
  </script>
</body>
</html>

