<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Voice Test</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 16px;
    }
    
    h1 {
      font-size: 20px;
      margin-bottom: 16px;
      color: #4CAF50;
    }
    
    .section {
      background: #252542;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .section h2 {
      font-size: 14px;
      color: #888;
      margin-bottom: 12px;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
      font-weight: bold;
    }
    
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #666;
    }
    
    .status-dot.listening {
      background: #4CAF50;
      animation: pulse 1s infinite;
    }
    
    .status-dot.processing {
      background: #FF9800;
    }
    
    .status-dot.ready {
      background: #2196F3;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
      font-family: monospace;
    }
    
    .stat-label {
      font-size: 11px;
      color: #888;
    }
    
    button {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-play {
      background: #4CAF50;
      color: white;
    }
    
    .btn-play:active:not(:disabled) {
      transform: scale(0.98);
    }
    
    .log {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      color: #aaa;
    }
    
    .log-entry {
      margin-bottom: 4px;
    }
    
    .log-entry.error {
      color: #f44336;
    }
    
    .log-entry.success {
      color: #4CAF50;
    }
    
    .hint {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¤ Voice Test</h1>
  
  <div class="section">
    <h2>Status</h2>
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Idle</span>
    </div>
    <p class="hint">Press KEY2 on Tapir to record</p>
    <p class="hint">Decoder: <span id="decoderStatus" style="color: #FF9800;">Loading...</span></p>
  </div>
  
  <div class="section">
    <h2>Live Stats</h2>
    <div class="stats">
      <div>
        <div class="stat-value" id="packetCount">0</div>
        <div class="stat-label">Packets</div>
      </div>
      <div>
        <div class="stat-value" id="bytesReceived">0</div>
        <div class="stat-label">Bytes</div>
      </div>
      <div>
        <div class="stat-value" id="duration">0.0s</div>
        <div class="stat-label">Duration</div>
      </div>
    </div>
  </div>
  
  <div class="section">
    <h2>Last Clip</h2>
    <button class="btn-play" id="playBtn" disabled>â–¶ Play Recording</button>
    <button class="btn-download" id="downloadBtn" disabled style="background:#2196F3;color:white;margin-top:8px;">â¬‡ Download OGG</button>
    <p class="hint" id="clipInfo">No recording yet</p>
  </div>
  
  <div class="section">
    <h2>Log</h2>
    <div class="log" id="log"></div>
  </div>

  <script>
    // ============================================================
    // State
    // ============================================================
    
    let opusFrames = [];
    let isRecording = false;
    let recordingStart = 0;
    let audioContext = null;
    let lastAudioBuffer = null;
    let durationInterval = null;
    
    // No external decoder needed - using native Web Audio API + OGG container
    document.getElementById('decoderStatus').textContent = 'âœ“ Native';
    document.getElementById('decoderStatus').style.color = '#4CAF50';
    
    // ============================================================
    // UI Elements
    // ============================================================
    
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const packetCountEl = document.getElementById('packetCount');
    const bytesReceivedEl = document.getElementById('bytesReceived');
    const durationEl = document.getElementById('duration');
    const playBtn = document.getElementById('playBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const clipInfoEl = document.getElementById('clipInfo');
    const logEl = document.getElementById('log');
    
    let lastOggData = null; // For download
    
    // ============================================================
    // Logging
    // ============================================================
    
    function log(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = 'log-entry' + (type !== 'info' ? ' ' + type : '');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(`[VoiceTest] ${msg}`);
    }
    
    // ============================================================
    // Voice Event Handlers
    // ============================================================
    
    function onVoiceStart() {
      log('Recording started');
      isRecording = true;
      recordingStart = Date.now();
      opusFrames = [];
      
      // Update UI
      statusDot.className = 'status-dot listening';
      statusText.textContent = 'Recording...';
      packetCountEl.textContent = '0';
      bytesReceivedEl.textContent = '0';
      durationEl.textContent = '0.0s';
      
      // Start duration timer
      durationInterval = setInterval(() => {
        const dur = (Date.now() - recordingStart) / 1000;
        durationEl.textContent = dur.toFixed(1) + 's';
      }, 100);
    }
    
    function onVoiceData(data) {
      if (!isRecording) return;
      
      // data.audio is base64-encoded Opus frame
      const opusBase64 = data.audio;
      if (opusBase64) {
        // Decode base64 to Uint8Array
        const binary = atob(opusBase64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        opusFrames.push(bytes);
        
        // Update stats
        const totalBytes = opusFrames.reduce((sum, f) => sum + f.length, 0);
        packetCountEl.textContent = opusFrames.length;
        bytesReceivedEl.textContent = totalBytes < 1024 
          ? totalBytes + ' B' 
          : (totalBytes / 1024).toFixed(1) + ' KB';
      }
    }
    
    async function onVoiceEnd() {
      log(`Recording ended: ${opusFrames.length} packets`);
      isRecording = false;
      
      // Stop duration timer
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
      }
      
      // Update UI
      statusDot.className = 'status-dot processing';
      statusText.textContent = 'Processing...';
      
      if (opusFrames.length === 0) {
        log('No audio data received', 'error');
        statusDot.className = 'status-dot';
        statusText.textContent = 'Idle';
        return;
      }
      
      // Try to decode Opus
      try {
        await decodeOpusFrames();
        statusDot.className = 'status-dot ready';
        statusText.textContent = 'Ready to play';
        playBtn.disabled = false;
        
        const totalBytes = opusFrames.reduce((sum, f) => sum + f.length, 0);
        const duration = lastAudioBuffer ? lastAudioBuffer.duration.toFixed(2) : '?';
        clipInfoEl.textContent = `${opusFrames.length} packets, ${totalBytes} bytes, ${duration}s`;
        
        log(`Decoded successfully: ${duration}s audio`, 'success');
      } catch (err) {
        log(`Decode failed: ${err.message}`, 'error');
        statusDot.className = 'status-dot';
        statusText.textContent = 'Decode failed';
        clipInfoEl.textContent = 'Decode error - see log';
      }
    }
    
    // ============================================================
    // Opus Decoding (Native Web Audio + OGG container)
    // ============================================================
    
    async function decodeOpusFrames() {
      // Initialize AudioContext
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      log(`Wrapping ${opusFrames.length} Opus frames in OGG container...`);
      
      // Log first frame info for debugging
      if (opusFrames.length > 0) {
        const f = opusFrames[0];
        log(`First frame: ${f.length} bytes, TOC: 0x${f[0].toString(16)}`);
      }
      
      // Build OGG/Opus container from raw frames
      const oggData = buildOggOpus(opusFrames, 16000, 1);
      lastOggData = oggData; // Save for download
      log(`OGG container: ${oggData.length} bytes`);
      
      // Debug: log first bytes
      const hex = Array.from(oggData.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
      log(`OGG header: ${hex}`);
      
      // Enable download button
      downloadBtn.disabled = false;
      
      // Decode using native Web Audio API
      const arrayBuffer = oggData.buffer.slice(
        oggData.byteOffset,
        oggData.byteOffset + oggData.byteLength
      );
      
      try {
        lastAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        log(`Decoded: ${lastAudioBuffer.duration.toFixed(2)}s @ ${lastAudioBuffer.sampleRate}Hz`);
      } catch (err) {
        log(`Native decode failed: ${err.message}`, 'error');
        log('Try downloading the OGG and testing in VLC/ffprobe', 'error');
        throw err;
      }
    }
    
    // ============================================================
    // OGG/Opus Container Builder (RFC 7845)
    // ============================================================
    
    function buildOggOpus(frames, inputSampleRate, channels) {
      const pages = [];
      let pageSequence = 0;
      let granulePosition = 0;
      
      // IMPORTANT: Opus internally always uses 48kHz
      // Granule positions are in 48kHz samples regardless of input rate
      const OPUS_INTERNAL_RATE = 48000;
      
      // Pre-skip: standard Opus encoder delay (3840 samples at 48kHz = 80ms)
      // For libopus default, it's typically 312 samples at input rate
      // At 48kHz: 312 * (48000/16000) = 936, but standard is often 3840
      const preSkip = 312 * (OPUS_INTERNAL_RATE / inputSampleRate);
      
      // Samples per frame at 48kHz (20ms frame = 960 samples)
      const samplesPerFrame48k = (20 * OPUS_INTERNAL_RATE) / 1000; // 960
      
      // OpusHead packet (19 bytes) - RFC 7845
      const opusHead = new Uint8Array(19);
      const headView = new DataView(opusHead.buffer);
      opusHead.set([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64]); // "OpusHead"
      opusHead[8] = 0x01;                    // Version 1
      opusHead[9] = channels;                // Channel count
      headView.setUint16(10, preSkip, true); // Pre-skip (LE)
      headView.setUint32(12, inputSampleRate, true); // Original sample rate (LE)
      headView.setInt16(16, 0, true);        // Output gain (0 dB)
      opusHead[18] = 0x00;                   // Channel mapping family 0
      
      // OpusTags packet - minimal valid tags
      const vendor = 'libopus';
      const opusTags = new Uint8Array(8 + 4 + vendor.length + 4);
      opusTags.set([0x4F, 0x70, 0x75, 0x73, 0x54, 0x61, 0x67, 0x73]); // "OpusTags"
      const tagsView = new DataView(opusTags.buffer);
      tagsView.setUint32(8, vendor.length, true);
      for (let i = 0; i < vendor.length; i++) {
        opusTags[12 + i] = vendor.charCodeAt(i);
      }
      tagsView.setUint32(12 + vendor.length, 0, true); // 0 user comments
      
      // Page 1: OpusHead (BOS flag = 0x02)
      pages.push(buildOggPage(opusHead, 0, pageSequence++, 0x02));
      
      // Page 2: OpusTags (granule = 0 for header pages)
      pages.push(buildOggPage(opusTags, 0, pageSequence++, 0x00));
      
      // Audio pages - put multiple frames per page for efficiency
      const FRAMES_PER_PAGE = 10;
      for (let i = 0; i < frames.length; i += FRAMES_PER_PAGE) {
        const pageFrames = frames.slice(i, Math.min(i + FRAMES_PER_PAGE, frames.length));
        granulePosition += pageFrames.length * samplesPerFrame48k;
        const isLast = (i + FRAMES_PER_PAGE) >= frames.length;
        pages.push(buildOggPageMulti(pageFrames, granulePosition, pageSequence++, isLast ? 0x04 : 0x00));
      }
      
      // Concatenate all pages
      const totalSize = pages.reduce((sum, p) => sum + p.length, 0);
      const result = new Uint8Array(totalSize);
      let offset = 0;
      for (const page of pages) {
        result.set(page, offset);
        offset += page.length;
      }
      
      return result;
    }
    
    // Build page with multiple packets (for audio frames)
    function buildOggPageMulti(packets, granulePos, seqNum, flags) {
      // Build segment table for multiple packets
      const segments = [];
      for (const pkt of packets) {
        let remaining = pkt.length;
        while (remaining >= 255) {
          segments.push(255);
          remaining -= 255;
        }
        segments.push(remaining); // Final segment (can be 0 to indicate exactly 255*n bytes)
      }
      
      const totalDataSize = packets.reduce((sum, p) => sum + p.length, 0);
      const headerSize = 27 + segments.length;
      const page = new Uint8Array(headerSize + totalDataSize);
      const view = new DataView(page.buffer);
      
      // OGG page header
      page.set([0x4F, 0x67, 0x67, 0x53], 0); // "OggS"
      page[4] = 0;                            // Version
      page[5] = flags;                        // Flags
      
      // Granule position (64-bit LE) - use BigInt for safety
      const gp = BigInt(granulePos);
      view.setUint32(6, Number(gp & 0xFFFFFFFFn), true);
      view.setUint32(10, Number((gp >> 32n) & 0xFFFFFFFFn), true);
      
      view.setUint32(14, 0x54415049, true);   // Serial "TAPI"
      view.setUint32(18, seqNum, true);       // Page sequence
      view.setUint32(22, 0, true);            // CRC placeholder
      page[26] = segments.length;             // Segment count
      
      // Segment table
      for (let i = 0; i < segments.length; i++) {
        page[27 + i] = segments[i];
      }
      
      // Packet data
      let offset = headerSize;
      for (const pkt of packets) {
        page.set(pkt, offset);
        offset += pkt.length;
      }
      
      // Calculate and set CRC
      const crc = oggCrc32(page);
      view.setUint32(22, crc, true);
      
      return page;
    }
    
    // Build page with single packet (for headers)
    function buildOggPage(data, granulePos, seqNum, flags) {
      return buildOggPageMulti([data], granulePos, seqNum, flags);
    }
    
    // OGG CRC-32 lookup table
    const oggCrcTable = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let r = i << 24;
      for (let j = 0; j < 8; j++) {
        r = (r & 0x80000000) ? ((r << 1) ^ 0x04C11DB7) : (r << 1);
      }
      oggCrcTable[i] = r >>> 0;
    }
    
    function oggCrc32(data) {
      let crc = 0;
      for (let i = 0; i < data.length; i++) {
        crc = (oggCrcTable[((crc >>> 24) ^ data[i]) & 0xFF] ^ (crc << 8)) >>> 0;
      }
      return crc;
    }
    
    // ============================================================
    // Playback
    // ============================================================
    
    async function playAudio() {
      if (!lastAudioBuffer) {
        log('No audio to play', 'error');
        return;
      }
      
      // Resume AudioContext if suspended (autoplay policy)
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      
      log('Playing audio...');
      playBtn.disabled = true;
      playBtn.textContent = 'â–¶ Playing...';
      
      const source = audioContext.createBufferSource();
      source.buffer = lastAudioBuffer;
      source.connect(audioContext.destination);
      
      source.onended = () => {
        log('Playback complete', 'success');
        playBtn.disabled = false;
        playBtn.textContent = 'â–¶ Play Recording';
      };
      
      source.start();
    }
    
    playBtn.addEventListener('click', playAudio);
    
    // Download OGG file for debugging
    downloadBtn.addEventListener('click', () => {
      if (!lastOggData) return;
      const blob = new Blob([lastOggData], { type: 'audio/ogg' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tapir-voice-${Date.now()}.ogg`;
      a.click();
      URL.revokeObjectURL(url);
      log('Downloaded OGG file');
    });
    
    // ============================================================
    // Bridge Integration
    // ============================================================
    
    // Prevent duplicate registration
    let bridgeRegistered = false;
    
    function setupBridge() {
      if (bridgeRegistered) {
        log('Bridge already registered, skipping');
        return;
      }
      
      if (window.tapir) {
        bridgeRegistered = true;
        log('Bridge connected');
        
        // Listen for voice events
        window.tapir.on('voice', (event) => {
          switch (event.type) {
            case 'start':
              onVoiceStart();
              break;
            case 'data':
              onVoiceData(event);
              break;
            case 'end':
              onVoiceEnd();
              break;
          }
        });
        
        log('Listening for voice events');
      } else {
        log('No bridge detected', 'error');
      }
    }
    
    // Try to setup bridge now, or wait for it
    if (window.tapir) {
      setupBridge();
    } else {
      // Bridge might be injected after script runs
      let attempts = 0;
      const checkBridge = setInterval(() => {
        attempts++;
        if (window.tapir) {
          clearInterval(checkBridge);
          setupBridge();
        } else if (attempts > 20) {
          clearInterval(checkBridge);
          log('Bridge not available after 2s', 'error');
        }
      }, 100);
    }
    
    log('Voice Test mini-app loaded');
  </script>
</body>
</html>

